/**
 * ************************************
 *
 * @module  injection.ts
 * @author  MADR Productions - AY
 * @date    9-25-23
 * @description middleware for server.use('/injection') to generate and send queries to test for SQL injection and evaluate response
 *
 * ************************************
 */

import { Request, Response } from 'express';
import {
  PentestType,
  GraphQLType,
  QueryResult,
} from '../functionsAndInputs/types.ts';
import {
  getBaseType,
  getSubFields,
  generateSQLQuery,
} from '../functionsAndInputs/generateHelper.ts';
import {
  SQLInputs,
  sqlErrorKeywords,
} from '../functionsAndInputs/inputsAndKeywords.ts';
import { SQLtitles } from '../functionsAndInputs/titles.ts';
import {
  createQueryResult,
  createErrorResult,
} from '../functionsAndInputs/query.ts';
import { info } from '../info.ts';
import {
  prettyPrintGraphQLQuery,
  prettifyJson,
} from '../functionsAndInputs/format.ts';

export const injection: PentestType = {
  generateQueries: async (req: Request, res: Response) => {
    console.log('Generating SQL Injection Queries...');
    const schemaTypes: GraphQLType[] = res.locals.schema.data.__schema.types;

    const arrOfQueries: string[] = [];

    for (const typeName of ['queryType', 'mutationType']) {
      const name: string | null =
        res.locals.schema.data.__schema[typeName]?.name;
      if (!name) continue;

      const types: GraphQLType | undefined = schemaTypes.find(
        (type) => type.name === name,
      );
      if (!types?.fields) continue;

      for (const field of types.fields) {
        if (
          !field.args ||
          field.args.some(
            (arg) => arg.type?.kind == 'SCALAR' && arg.type?.name === 'String',
          )
        ) {
          for (const input of SQLInputs) {
            const query = generateSQLQuery(field, input, typeName, schemaTypes);
            arrOfQueries.push(query);
          }
        }
      }
    }
    res.locals.SQLQueries = arrOfQueries;
    console.log('Generated Injection Queries...');
    return;
  },
  attack: async (req: Request, res: Response): Promise<QueryResult[]> => {
    console.log('Sending SQL Injections...');

    const results: QueryResult[] = [];
    const API: string = req.body.API;
    let ID: number = 1;

    const sendReqAndEvaluate = async (query: string): Promise<QueryResult> => {
      const queryResult = createQueryResult(
        'INJ',
        prettyPrintGraphQLQuery(query),
        ID,
      );
      const errorResult = createErrorResult(
        'INJ',
        prettyPrintGraphQLQuery(query),
        ID,
      );
      ID++;

      try {
        const sendTime = Date.now();

        const data = await fetch(API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/graphql',
          },
          body: query,
        }).catch((err) => console.log(err));

        if (!data) {
          return errorResult;
        }

        const response = await data.json();
        const timeTaken = Date.now() - sendTime;
        queryResult.testDuration = `${timeTaken} ms`;
        queryResult.details.response = prettifyJson(response);
        queryResult.details.link = info['INJ-URI'];

        if (query.includes('OR 1') || query.includes("OR '1")) {
          queryResult.title = SQLtitles.booleanBased;
          queryResult.details.description = info['Boolean Based SQL Injection'];
          queryResult.details.solution = info['BBSQLI Solution'];
        } else if (
          query.toLowerCase().includes('sleep') ||
          query.toLowerCase().includes('delay')
        ) {
          queryResult.title = SQLtitles.timeBased;
          queryResult.details.description =
            info['Time-Based Blind SQL Injection'];
          queryResult.details.solution = info['TMSQLI Solution'];
        } else if (
          query.includes("'") ||
          query.includes(';') ||
          query.includes('--')
        ) {
          queryResult.title = SQLtitles.errorBased;
          queryResult.details.description = info['Error Based SQL Injection'];
          queryResult.details.solution = info['EBSQLI Solution'];
        }

        if (response.data) {
          const keys: string[] = Object.keys(response.data);
          for (const key of keys) {
            if (
              Array.isArray(response.data[key]) &&
              response.data[key].length > 1
            ) {
              queryResult.status = 'Fail';
              queryResult.details.error =
                'Potentially Excessive/Sensitive Information Given';
            }
          }
        }

        if (
          response.errors &&
          response.errors.some((error: { message: string }) =>
            sqlErrorKeywords.some((keyword) =>
              error.message.toLowerCase().includes(keyword),
            ),
          )
        ) {
          queryResult.status = 'Fail';
          queryResult.details.error =
            'Potential Exposure of Sensitive Information Through Error Message';
        }
        if (timeTaken > 5000) {
          queryResult.status = 'Fail';
          queryResult.details.error =
            'Server Response Delayed Due to Injection';
        }
        return queryResult;
      } catch (err) {
        console.log(err);
        return errorResult;
      }
    };
    const arrofQueries: string[] = res.locals.SQLQueries;

    for (const query of arrofQueries) {
      const result = await sendReqAndEvaluate(query);
      results.push(result);
    }
    return results;
  },
};
