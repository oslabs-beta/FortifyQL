/**
 * ************************************
 *
 * @module  batching.ts
 * @author  MADR Productions - AY
 * @date    9-25-23
 * @description middleware for server.use('/injection') to generate and send queries to test for SQL injection and evaluate response
 *
 * ************************************
 */

import { Request, Response } from 'express';
import {
  PentestType,
  GraphQLType,
  QueryResult,
} from '../functionsAndInputs/types.ts';
import {
  generateBatchQuery,
  generateQueryNested,
} from '../functionsAndInputs/generateHelper.ts';
import {
  createQueryResult,
  createErrorResult,
} from '../functionsAndInputs/query.ts';
import { batchTitles } from '../functionsAndInputs/titles.ts';
import { batchingErrorKeywords } from '../functionsAndInputs/inputsAndKeywords.ts';
import { info } from '../info.ts';
import {
  prettyPrintGraphQLBatchQuery,
  prettyPrintGraphQLQuery,
  prettifyJson,
} from '../functionsAndInputs/format.ts';

export const batching: PentestType = {
  generateQueries: async (req: Request, res: Response) => {
    console.log('Generating Batching Queries...');
    const schemaTypes: GraphQLType[] = res.locals.schema.data.__schema.types;

    /*
    Generates a nested GraphQL query string for selecting subfields
    of a given GraphQL type up to a specified maximum depth.
    */

    const arrOfQueries: (string | string[])[] = [];
    const arrOfNested: string[] = [];

    for (const typeName of ['queryType', 'mutationType']) {
      const name: string | null =
        res.locals.schema.data.__schema[typeName]?.name;
      if (!name) continue;

      const types: GraphQLType | undefined = schemaTypes.find(
        (type) => type.name === name,
      );
      if (!types?.fields) continue;

      for (const field of types.fields) {
        const singularQuery: string = generateBatchQuery(
          field,
          typeName,
          schemaTypes,
        );
        const identicalQuery: string[] = new Array(10).fill(singularQuery);
        arrOfQueries.push(identicalQuery);
        const nestedQuery = generateQueryNested(field, typeName, schemaTypes);
        arrOfNested.push(nestedQuery);
      }
    }
    arrOfQueries.push(arrOfNested);
    res.locals.batchingQueries = arrOfQueries;
    console.log('Generated Batching Queries...');
    return;
  },
  attack: async (req: Request, res: Response): Promise<QueryResult[]> => {
    console.log('Sending Batching Queries...');

    const results: QueryResult[] = [];
    const API: string = req.body.API;
    let ID: number = 1;

    const sendReqAndEvaluate = async (query: string): Promise<QueryResult> => {
      console.log(query);
      const queryResult = createQueryResult(
        'BATCH',
        prettyPrintGraphQLQuery(query),
        ID,
      );
      const errorResult = createErrorResult(
        'BATCH',
        prettyPrintGraphQLQuery(query),
        ID,
      );
      ID++;

      try {
        const sendTime = Date.now();

        const data = await fetch(API, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/graphql',
          },
          body: query,
        }).catch((err) => console.log(err));

        if (!data) {
          return errorResult;
        }

        const response = await data.json();
        const timeTaken = Date.now() - sendTime;
        queryResult.testDuration = `${timeTaken} ms`;
        queryResult.details.response = prettifyJson(response);
        queryResult.details.link = info['BATCH-URI'];

        if (query[0] === query[1]) {
          queryResult.title = batchTitles.identical;
          queryResult.details.description =
            info['Multiple Identical Batching Attack'];
          queryResult.details.solution = info['MIBA Solution'];
        } else {
          queryResult.title = batchTitles.exhaustive;
          queryResult.details.description =
            info['Resource Exhaustive and Nested Batching Attack'];
          queryResult.details.solution = info['REANBA Solution'];
        }

        if (response.data) {
          queryResult.status = 'Fail';
          queryResult.details.error =
            'Batching is Enabled, Rate Limiting Not Found';
        }
        if (response.errors) {
          if (
            response.errors.some((error: { message: string }) =>
              batchingErrorKeywords.some((keyword) =>
                error.message.toLowerCase().includes(keyword),
              ),
            )
          ) {
            queryResult.status = 'Fail';
            queryResult.details.error =
              'Potential Exposure of Sensitive Information Through Error Message';
          }
        }
        return queryResult;
      } catch (err) {
        console.log(err);
        return errorResult;
      }
    };
    const arrofQueries: string[] = res.locals.batchingQueries;

    for (const query of arrofQueries) {
      const result = await sendReqAndEvaluate(query);
      results.push(result);
    }
    return results;
  },
};
